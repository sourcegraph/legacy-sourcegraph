diff --git a/internal/instrumentation/BUILD.bazel b/internal/instrumentation/BUILD.bazel
index 6fd63bc4a4..00d5c85ef4 100644
--- a/internal/instrumentation/BUILD.bazel
+++ b/internal/instrumentation/BUILD.bazel
@@ -10,7 +10,7 @@ go_library(
         "@io_opentelemetry_go_contrib_instrumentation_net_http_otelhttp//:otelhttp",
         "@io_opentelemetry_go_otel//:otel",
         "@io_opentelemetry_go_otel//attribute",
-        "@io_opentelemetry_go_otel_metric//:metric",
+        "@io_opentelemetry_go_otel_metric//noop",
         "@io_opentelemetry_go_otel_trace//:trace",
     ],
 )
diff --git a/internal/instrumentation/http.go b/internal/instrumentation/http.go
index 119f379746..8978a29911 100644
--- a/internal/instrumentation/http.go
+++ b/internal/instrumentation/http.go
@@ -8,40 +8,76 @@ import (
 	"go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
 	"go.opentelemetry.io/otel"
 	"go.opentelemetry.io/otel/attribute"
-	"go.opentelemetry.io/otel/metric"
+	"go.opentelemetry.io/otel/metric/noop"
 	"go.opentelemetry.io/otel/trace"
 
 	"github.com/sourcegraph/sourcegraph/internal/trace/policy"
 )
 
+// defaultOTELHTTPOptions is a set of options shared between instrumetned HTTP middleware
+// and HTTP clients for consistent Sourcegraph-preferred behaviour.
+var defaultOTELHTTPOptions = []otelhttp.Option{
+	// Trace policy management
+	otelhttp.WithTracerProvider(&samplingRetainTracerProvider{}),
+	otelhttp.WithFilter(func(r *http.Request) bool {
+		return policy.ShouldTrace(r.Context())
+	}),
+	// Uniform span names
+	otelhttp.WithSpanNameFormatter(func(operation string, r *http.Request) string {
+		// If incoming, just include the path since our own host is not
+		// very interesting. If outgoing, include the host as well.
+		target := r.URL.Path
+		if r.RemoteAddr == "" { // no RemoteAddr indicates this is an outgoing request
+			target = r.Host + target
+		}
+		if operation != "" {
+			return fmt.Sprintf("%s.%s %s", operation, r.Method, target)
+		}
+		return fmt.Sprintf("%s %s", r.Method, target)
+	}),
+	// Disable OTEL metrics which can be quite high-cardinality
+	otelhttp.WithMeterProvider(noop.NewMeterProvider()),
+	// Make sure we use the global propagator, which should be set up on
+	// service initialization to support all our commonly used propagation
+	// formats (OpenTelemetry, W3c, Jaeger, etc)
+	otelhttp.WithPropagators(otel.GetTextMapPropagator()),
+}
+
 // HTTPMiddleware wraps the handler with the following:
 //
 //   - If the HTTP header, X-Sourcegraph-Should-Trace, is set to a truthy value, set the
 //     shouldTraceKey context.Context value to true
 //   - go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp, which applies the
-//     desired instrumentation.
+//     desired instrumentation, including picking up traces propagated in the request headers
+//     using the globally configured propagator.
 //
 // The provided operation name is used to add details to spans.
-func HTTPMiddleware(operation string, h http.Handler, opts ...otelhttp.Option) http.Handler {
-	instrumentedHandler := otelhttp.NewHandler(h, operation,
-		append(
-			[]otelhttp.Option{
-				otelhttp.WithTracerProvider(&samplingRetainTracerProvider{}),
-				otelhttp.WithFilter(func(r *http.Request) bool {
-					return policy.ShouldTrace(r.Context())
-				}),
-				otelhttp.WithSpanNameFormatter(func(operation string, r *http.Request) string {
-					if operation != "" {
-						return fmt.Sprintf("%s.%s %s", operation, r.Method, r.URL.Path)
-					}
-					return fmt.Sprintf("%s %s", r.Method, r.URL.Path)
-				}),
-				otelhttp.WithMeterProvider(metric.NewNoopMeterProvider()),
-			},
-			opts...,
-		)...)
+func HTTPMiddleware(operation string, next http.Handler, opts ...otelhttp.Option) http.Handler {
+	afterInstrumentedHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		// Set X-Trace after otelhttp's handler which starts the trace. The
+		// top-level trace should be an OTEL trace, so we use otel/trace to
+		// extract it. Then, we add it to the header before next writes the
+		// header back to client.
+		span := trace.SpanContextFromContext(r.Context())
+		if span.IsValid() {
+			// We only set the trace ID here. The trace URL is set to
+			// X-Trace-URL by httptrace.HTTPMiddleware that does some more
+			// elaborate handling. In particular, we don't want to introduce
+			// a conf.Get() dependency here to build the trace URL, since we
+			// want this to be fairly bare-bones for use in standalone services
+			// like Cody Gateway.
+			w.Header().Set("X-Trace", span.TraceID().String())
+			w.Header().Set("X-Trace-Span", span.SpanID().String())
+		}
+
+		next.ServeHTTP(w, r)
+	})
+
+	instrumentedHandler := otelhttp.NewHandler(afterInstrumentedHandler, operation,
+		append(defaultOTELHTTPOptions, opts...)...)
 
 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		// Set up trace policy before instrumented handler
 		var shouldTrace bool
 		switch policy.GetTracePolicy() {
 		case policy.TraceSelective:
@@ -87,3 +123,9 @@ func (t *samplingRetainTracer) Start(ctx context.Context, spanName string, opts
 	}
 	return t.tracer.Start(ctx, spanName, opts...)
 }
+
+// NewHTTPTransport creates an http.RoundTripper that instruments all requests using
+// OpenTelemetry and a default set of OpenTelemetry options.
+func NewHTTPTransport(base http.RoundTripper, opts ...otelhttp.Option) *otelhttp.Transport {
+	return otelhttp.NewTransport(base, append(defaultOTELHTTPOptions, opts...)...)
+}
