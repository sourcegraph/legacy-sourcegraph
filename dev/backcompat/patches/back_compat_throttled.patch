diff --git a/cmd/frontend/graphqlbackend/rate_limit.go b/cmd/frontend/graphqlbackend/rate_limit.go
index d147e5af4c..a84eb765c8 100644
--- a/cmd/frontend/graphqlbackend/rate_limit.go
+++ b/cmd/frontend/graphqlbackend/rate_limit.go
@@ -1,6 +1,7 @@
 package graphqlbackend
 
 import (
+	"context"
 	"strconv"
 	"sync/atomic"
 
@@ -13,7 +14,6 @@ import (
 	"github.com/sourcegraph/sourcegraph/internal/conf"
 	"github.com/sourcegraph/sourcegraph/internal/trace"
 	"github.com/sourcegraph/sourcegraph/lib/errors"
-	"github.com/sourcegraph/sourcegraph/schema"
 
 	"github.com/sourcegraph/log"
 )
@@ -370,14 +370,14 @@ type LimiterArgs struct {
 }
 
 type Limiter interface {
-	RateLimit(key string, quantity int, args LimiterArgs) (bool, throttled.RateLimitResult, error)
+	RateLimit(ctx context.Context, key string, quantity int, args LimiterArgs) (bool, throttled.RateLimitResult, error)
 }
 
 type LimitWatcher interface {
 	Get() (Limiter, bool)
 }
 
-func NewBasicLimitWatcher(logger log.Logger, store throttled.GCRAStore) *BasicLimitWatcher {
+func NewBasicLimitWatcher(logger log.Logger, store throttled.GCRAStoreCtx) *BasicLimitWatcher {
 	basic := &BasicLimitWatcher{
 		store: store,
 	}
@@ -392,7 +392,10 @@ func NewBasicLimitWatcher(logger log.Logger, store throttled.GCRAStore) *BasicLi
 	return basic
 }
 
-type BasicLimitWatcher RateLimitWatcher
+type BasicLimitWatcher struct {
+	store throttled.GCRAStoreCtx
+	rl    atomic.Value // *RateLimiter
+}
 
 func (bl *BasicLimitWatcher) updateFromConfig(logger log.Logger, limit int) {
 	if limit <= 0 {
@@ -401,7 +404,7 @@ func (bl *BasicLimitWatcher) updateFromConfig(logger log.Logger, limit int) {
 		return
 	}
 	maxBurstPercentage := 0.2
-	l, err := throttled.NewGCRARateLimiter(
+	l, err := throttled.NewGCRARateLimiterCtx(
 		bl.store,
 		throttled.RateQuota{
 			MaxRate:  throttled.PerHour(limit),
@@ -426,156 +429,15 @@ func (bl *BasicLimitWatcher) Get() (Limiter, bool) {
 }
 
 type BasicLimiter struct {
-	*throttled.GCRARateLimiter
+	*throttled.GCRARateLimiterCtx
 	enabled bool
 }
 
 // RateLimit limits unauthenticated requests to the GraphQL API with an equal
 // quantity of 1.
-func (bl *BasicLimiter) RateLimit(_ string, _ int, args LimiterArgs) (bool, throttled.RateLimitResult, error) {
-	if args.Anonymous && args.RequestName == "unknown" && args.RequestSource == trace.SourceOther && bl.GCRARateLimiter != nil {
-		return bl.GCRARateLimiter.RateLimit("basic", 1)
+func (bl *BasicLimiter) RateLimit(ctx context.Context, _ string, _ int, args LimiterArgs) (bool, throttled.RateLimitResult, error) {
+	if args.Anonymous && args.RequestName == "unknown" && args.RequestSource == trace.SourceOther && bl.GCRARateLimiterCtx != nil {
+		return bl.GCRARateLimiterCtx.RateLimitCtx(ctx, "basic", 1)
 	}
 	return false, throttled.RateLimitResult{}, nil
 }
-
-// RateLimitWatcher stores the currently configured rate limiter and whether or
-// not rate limiting is enabled.
-type RateLimitWatcher struct {
-	store throttled.GCRAStore
-	rl    atomic.Value // *RateLimiter
-}
-
-// NewRateLimiteWatcher creates a new limiter with the provided store and starts
-// watching for config changes.
-func NewRateLimiteWatcher(logger log.Logger, store throttled.GCRAStore) *RateLimitWatcher {
-	w := &RateLimitWatcher{
-		store: store,
-	}
-
-	conf.Watch(func() {
-		logger.Debug("Rate limit config updated, applying changes")
-		w.updateFromConfig(logger, conf.Get().ApiRatelimit)
-	})
-
-	return w
-}
-
-// Get returns the current rate limiter. If rate limiting is currently disabled
-// (nil, false) is returned.
-func (w *RateLimitWatcher) Get() (Limiter, bool) {
-	if l, ok := w.rl.Load().(*RateLimiter); ok && l.enabled {
-		return l, true
-	}
-	return nil, false
-}
-
-func (w *RateLimitWatcher) updateFromConfig(logger log.Logger, rlc *schema.ApiRatelimit) {
-	// We can burst up to a max of 20% of limit
-	maxBurstPercentage := 0.2
-
-	if rlc == nil || !rlc.Enabled {
-		w.rl.Store(&RateLimiter{enabled: false})
-		return
-	}
-
-	ipQuota := throttled.RateQuota{
-		MaxRate:  throttled.PerHour(rlc.PerIP),
-		MaxBurst: int(float64(rlc.PerIP) * maxBurstPercentage),
-	}
-	ipLimiter, err := throttled.NewGCRARateLimiter(w.store, ipQuota)
-	if err != nil {
-		logger.Warn("error creating ip rate limiter", log.Error(err))
-		return
-	}
-
-	userQuota := throttled.RateQuota{
-		MaxRate:  throttled.PerHour(rlc.PerUser),
-		MaxBurst: int(float64(rlc.PerUser) * maxBurstPercentage),
-	}
-	userLimiter, err := throttled.NewGCRARateLimiter(w.store, userQuota)
-	if err != nil {
-		logger.Warn("error creating user rate limiter", log.Error(err))
-		return
-	}
-
-	overrides := make(map[string]limiter)
-	for _, o := range rlc.Overrides {
-		switch l := o.Limit.(type) {
-		case string:
-			if l == "blocked" {
-				overrides[o.Key] = &fixedLimiter{
-					limited: true,
-					result: throttled.RateLimitResult{
-						Limit:      0,
-						Remaining:  0,
-						ResetAfter: 0,
-						RetryAfter: 0,
-					},
-				}
-			} else if l == "unlimited" {
-				overrides[o.Key] = &fixedLimiter{
-					limited: false,
-					result: throttled.RateLimitResult{
-						Limit:      100000,
-						Remaining:  100000,
-						ResetAfter: 0,
-						RetryAfter: 0,
-					},
-				}
-			} else {
-				logger.Warn("unknown limit value", log.String("value", l))
-				return
-			}
-		case int:
-			rl, err := throttled.NewGCRARateLimiter(w.store, throttled.RateQuota{
-				MaxRate:  throttled.PerHour(l),
-				MaxBurst: int(float64(l) * maxBurstPercentage),
-			})
-			if err != nil {
-				logger.Warn("error creating override rate limiter", log.String("key", o.Key), log.Error(err))
-				return
-			}
-			overrides[o.Key] = rl
-		}
-	}
-
-	// Store the new limiter
-	w.rl.Store(&RateLimiter{
-		enabled:     true,
-		ipLimiter:   ipLimiter,
-		userLimiter: userLimiter,
-		overrides:   overrides,
-	})
-}
-
-type RateLimiter struct {
-	enabled     bool
-	ipLimiter   *throttled.GCRARateLimiter
-	userLimiter *throttled.GCRARateLimiter
-	overrides   map[string]limiter
-}
-
-func (rl *RateLimiter) RateLimit(uid string, cost int, args LimiterArgs) (bool, throttled.RateLimitResult, error) {
-	if r, ok := rl.overrides[uid]; ok {
-		return r.RateLimit(uid, cost)
-	}
-	if args.IsIP {
-		return rl.ipLimiter.RateLimit(uid, cost)
-	}
-	return rl.userLimiter.RateLimit(uid, cost)
-}
-
-type limiter interface {
-	RateLimit(string, int) (bool, throttled.RateLimitResult, error)
-}
-
-// fixedLimiter is a rate limiter that always returns the same result
-type fixedLimiter struct {
-	limited bool
-	result  throttled.RateLimitResult
-}
-
-func (f *fixedLimiter) RateLimit(string, int) (bool, throttled.RateLimitResult, error) {
-	return f.limited, f.result, nil
-}
diff --git a/cmd/frontend/graphqlbackend/rate_limit_test.go b/cmd/frontend/graphqlbackend/rate_limit_test.go
index 8d7c9e4295..f4803a5b7e 100644
--- a/cmd/frontend/graphqlbackend/rate_limit_test.go
+++ b/cmd/frontend/graphqlbackend/rate_limit_test.go
@@ -1,18 +1,16 @@
 package graphqlbackend
 
 import (
+	"context"
 	"fmt"
 	"testing"
-	"time"
 
 	"github.com/google/go-cmp/cmp"
-	"github.com/throttled/throttled/v2"
 	"github.com/throttled/throttled/v2/store/memstore"
 
 	"github.com/sourcegraph/log/logtest"
 
 	"github.com/sourcegraph/sourcegraph/internal/trace"
-	"github.com/sourcegraph/sourcegraph/schema"
 )
 
 func TestEstimateQueryCost(t *testing.T) {
@@ -393,172 +391,6 @@ fragment UsableFields on Usable {
 	}
 }
 
-func TestRatelimitFromConfig(t *testing.T) {
-	testCases := []struct {
-		name   string
-		config *schema.ApiRatelimit
-
-		uid  string
-		isIP bool
-		cost int
-
-		enabled bool
-
-		wantLimited bool
-		wantResult  throttled.RateLimitResult
-	}{
-		{
-			name:   "Nil config",
-			config: nil,
-
-			enabled: false,
-		},
-		{
-			name: "Disabled config",
-			config: &schema.ApiRatelimit{
-				Enabled: false,
-			},
-			enabled: false,
-		},
-		{
-			name: "No overrides",
-			config: &schema.ApiRatelimit{
-				Enabled:   true,
-				Overrides: nil,
-				PerIP:     5000,
-				PerUser:   5000,
-			},
-			enabled: true,
-
-			uid:  "test",
-			isIP: false,
-			cost: 1,
-
-			wantLimited: false,
-			wantResult: throttled.RateLimitResult{
-				Limit:      1001,
-				Remaining:  1000,
-				ResetAfter: 720 * time.Millisecond,
-				RetryAfter: -1,
-			},
-		},
-		{
-			name: "With value override",
-			config: &schema.ApiRatelimit{
-				Enabled: true,
-				PerIP:   5000,
-				PerUser: 5000,
-				Overrides: []*schema.Overrides{
-					{
-						Key:   "test",
-						Limit: 2500,
-					},
-				},
-			},
-			enabled: true,
-
-			uid:  "test",
-			isIP: false,
-			cost: 1,
-
-			wantLimited: false,
-			wantResult: throttled.RateLimitResult{
-				Limit:      501,
-				Remaining:  500,
-				ResetAfter: 720 * time.Millisecond * 2,
-				RetryAfter: -1,
-			},
-		},
-		{
-			name: "With blocked override",
-			config: &schema.ApiRatelimit{
-				Enabled: true,
-				PerIP:   5000,
-				PerUser: 5000,
-				Overrides: []*schema.Overrides{
-					{
-						Key:   "test",
-						Limit: "blocked",
-					},
-				},
-			},
-			enabled: true,
-
-			uid:  "test",
-			isIP: false,
-			cost: 1,
-
-			wantLimited: true,
-			wantResult: throttled.RateLimitResult{
-				Limit:      0,
-				Remaining:  0,
-				ResetAfter: 0,
-				RetryAfter: 0,
-			},
-		},
-		{
-			name: "With unlimited override",
-			config: &schema.ApiRatelimit{
-				Enabled: true,
-				PerIP:   5000,
-				PerUser: 5000,
-				Overrides: []*schema.Overrides{
-					{
-						Key:   "test",
-						Limit: "unlimited",
-					},
-				},
-			},
-			enabled: true,
-
-			uid:  "test",
-			isIP: false,
-			cost: 1,
-
-			wantLimited: false,
-			wantResult: throttled.RateLimitResult{
-				Limit:      100000,
-				Remaining:  100000,
-				ResetAfter: 0,
-				RetryAfter: 0,
-			},
-		},
-	}
-
-	for _, tc := range testCases {
-		t.Run(tc.name, func(t *testing.T) {
-			store, err := memstore.New(1024)
-			if err != nil {
-				t.Fatal(err)
-			}
-
-			logger := logtest.Scoped(t)
-
-			rlw := NewRateLimiteWatcher(logger, store)
-
-			rlw.updateFromConfig(logger, tc.config)
-			rl, enabled := rlw.Get()
-
-			if tc.enabled != enabled {
-				t.Fatalf("Want %v, got %v", tc.enabled, enabled)
-			}
-			if !tc.enabled {
-				return
-			}
-			limited, result, err := rl.RateLimit(tc.uid, tc.cost, LimiterArgs{IsIP: tc.isIP})
-			if err != nil {
-				t.Fatal(err)
-			}
-			if limited != tc.wantLimited {
-				t.Fatalf("Limited, want %v got %v", tc.wantLimited, limited)
-			}
-			if diff := cmp.Diff(tc.wantResult, result); diff != "" {
-				t.Fatal(diff)
-			}
-		})
-	}
-}
-
 func TestBasicLimiterEnabled(t *testing.T) {
 	tests := []struct {
 		limit       int
@@ -584,7 +416,7 @@ func TestBasicLimiterEnabled(t *testing.T) {
 
 	for _, tt := range tests {
 		t.Run(fmt.Sprintf("limit:%d", tt.limit), func(t *testing.T) {
-			store, err := memstore.New(1)
+			store, err := memstore.NewCtx(1)
 			if err != nil {
 				t.Fatal(err)
 			}
@@ -604,7 +436,7 @@ func TestBasicLimiterEnabled(t *testing.T) {
 }
 
 func TestBasicLimiter(t *testing.T) {
-	store, err := memstore.New(1)
+	store, err := memstore.NewCtx(1)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -627,7 +459,7 @@ func TestBasicLimiter(t *testing.T) {
 	}
 
 	// 1st call should not be limited.
-	limited, _, err := limiter.RateLimit("", 1, limiterArgs)
+	limited, _, err := limiter.RateLimit(context.Background(), "", 1, limiterArgs)
 	if err != nil {
 		t.Fatal(err)
 	}
@@ -636,7 +468,7 @@ func TestBasicLimiter(t *testing.T) {
 	}
 
 	// 2nd call should be limited.
-	limited, _, err = limiter.RateLimit("", 1, limiterArgs)
+	limited, _, err = limiter.RateLimit(context.Background(), "", 1, limiterArgs)
 	if err != nil {
 		t.Fatal(err)
 	}
diff --git a/cmd/frontend/internal/cli/serve_cmd.go b/cmd/frontend/internal/cli/serve_cmd.go
index 43c397266e..1fdf7e5439 100644
--- a/cmd/frontend/internal/cli/serve_cmd.go
+++ b/cmd/frontend/internal/cli/serve_cmd.go
@@ -369,14 +369,14 @@ func isAllowedOrigin(origin string, allowedOrigins []string) bool {
 }
 
 func makeRateLimitWatcher() (*graphqlbackend.BasicLimitWatcher, error) {
-	var store throttled.GCRAStore
+	var store throttled.GCRAStoreCtx
 	var err error
 	if pool, ok := redispool.Cache.Pool(); ok {
-		store, err = redigostore.New(pool, "gql:rl:", 0)
+		store, err = redigostore.NewCtx(pool, "gql:rl:", 0)
 	} else {
 		// If redis is disabled we are in Sourcegraph App and can rely on an
 		// in-memory store.
-		store, err = memstore.New(0)
+		store, err = memstore.NewCtx(0)
 	}
 	if err != nil {
 		return nil, err
diff --git a/cmd/frontend/internal/httpapi/api_test.go b/cmd/frontend/internal/httpapi/api_test.go
index f3f830abbf..c1e85158bb 100644
--- a/cmd/frontend/internal/httpapi/api_test.go
+++ b/cmd/frontend/internal/httpapi/api_test.go
@@ -24,8 +24,8 @@ func init() {
 func newTest(t *testing.T) *httptestutil.Client {
 	logger := logtest.Scoped(t)
 	enterpriseServices := enterprise.DefaultServices()
-	rateLimitStore, _ := memstore.New(1024)
-	rateLimiter := graphqlbackend.NewRateLimiteWatcher(logger, rateLimitStore)
+	rateLimitStore, _ := memstore.NewCtx(1024)
+	rateLimiter := graphqlbackend.NewBasicLimitWatcher(logger, rateLimitStore)
 
 	db := database.NewMockDB()
 
diff --git a/cmd/frontend/internal/httpapi/graphql.go b/cmd/frontend/internal/httpapi/graphql.go
index f197cbc187..dbc7860a33 100644
--- a/cmd/frontend/internal/httpapi/graphql.go
+++ b/cmd/frontend/internal/httpapi/graphql.go
@@ -92,7 +92,7 @@ func serveGraphQL(logger sglog.Logger, schema *graphql.Schema, rlw graphqlbacken
 			traceData.cost = cost
 
 			if rl, enabled := rlw.Get(); enabled && cost != nil {
-				limited, result, err := rl.RateLimit(uid, cost.FieldCount, graphqlbackend.LimiterArgs{
+				limited, result, err := rl.RateLimit(r.Context(), uid, cost.FieldCount, graphqlbackend.LimiterArgs{
 					IsIP:          isIP,
 					Anonymous:     anonymous,
 					RequestName:   requestName,
