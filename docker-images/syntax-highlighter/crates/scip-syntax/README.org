* Determining (file-)local definitions and references

** Hoisting behaviour

*** Python does have hoisting
#+begin_src python :results output
  x = 10 # def 1

  def my_fun():
      print(f"global first {x}") # ref 2
      x = 20 # def 2

  my_fun()
#+end_src

Results in the following error:
: Traceback (most recent call last):
:   File "<stdin>", line 7, in <module>
:   File "<stdin>", line 4, in my_fun
: UnboundLocalError: cannot access local variable 'x' where it is not associated with a value

Variables are not exactly lexically scoped. While they can be
referenced, assigning to a variable from a parent scope in a nested
function actually creates a new local binding in that function
instead. This can be circumvented using the =global= or =nonlocal=
keywords, but I don't know how I'd go about handling that in a
language-agnostic fashion.

Notably Python hoists to the function level, assigning a variable in a
nested-if creates a new function scoped variable

#+begin_src python :results output
  y = 0 # def 0
  x = 10 # def 4

  def outer():
      y = 10 # def 1
      def inner():
        y = 20 # def 2
        print(f"{x} and {y} from inner") # ref 3, ref 2
      x = 40 # def 3
      inner()
      print(f"{x} and {y} from outer") # ref 3, ref 1
  outer()
#+end_src

Results:
: 40 and 20 from inner
: 40 and 10 from outer

*** JS/TS does have hoisting

Here's a program that shows that JS uses hoisting for both let and
var, but var is hoisted to the nearest function scope, while let is
block scoped.

#+begin_src js :results output
  let y = 15 // def 1

  function outer() {
      function inner() {
          { var y = 20 }; // def 2
          console.log(`${x} and ${y} from inner`) // ref 5, ref 2
      };

      function inner2() {
          { let y = 20 }; // def 3
          // Captures the y from _outer_ and not the global because of
          // hoisting
          console.log(`${x} and ${y} from inner2`) // ref 5, ref 4
      };

      let y = 10; // def 4
      var x = 40; // def 5
      inner();
      inner2();
      console.log(`${x} and ${y} from outer`); // ref 5, ref 4
  }
  outer()
#+end_src

Results:
: 40 and 20 from inner
: 40 and 10 from inner2
: 40 and 10 from outer

*** Java does not have hoisting, but we can treat it as if it did anyway

While Java does not exactly do hoisting, it also doesn't allow the
kinds of shadowing one would need to exploit that fact. We can treat
it as if it did do (block scoped) hoisting, and we'd only 'get it
wrong' for code that javac wouldn't accept anyway.

*** Scala does not have hoisting, but we can treat it as if it did anyway

While Scala is fine with shadowing it still does not allow two
different references to a variable of the same name in the same block.
This means it can also be treated as a language with (block scoped)
hoisting.

*** Go does not have hoisting
Here's a program showing how Go has full lexical scoping.

#+begin_src go :results output
package main

import "fmt"

var x = 10 // def 1

func myFun() {
        fmt.Printf("global first %v\n", x) // ref 1
        x = 40 // ref 1

        var x = 20 // def 2
        fmt.Printf("local first %v\n", x) // ref 2
        x = 30 // ref 2
        fmt.Printf("local second %v\n", x) // ref 2
}

func main() {
        myFun()
        fmt.Printf("global second %v\n", x) // ref 1
}
#+end_src

Results:
: global first 10
: local first 20
: local second 30
: global second 40

*** Perl does not have hoisting
Here's a program showing how Perl has full lexical scoping (for =my=
variables). It also has full on dynamic scoping with the =local=
keyword, but there's no hope for statically analyzing that.
#+begin_src perl :results output
  my $x = 10; # def 1

  sub my_fun {
      print "global first $x\n"; # ref 1
      $x = 40; # ref 1

      my $x = 20; # def 2
      print "local first $x\n"; # ref 2
      $x = 30; # ref 2
      print "local second $x\n"; # ref 2
  }

  my_fun();

  print "global second: $x\n"; # ref 1
#+end_src

Results:
: global first 10
: local first 20
: local second 30
: global second: 40


** How to adapt the current implementation

The current implementation basically implements block-scoped hoisting
regardless of language or captures. To properly support the languages
listed above, we'd need to add the ability to specify hoisting
behaviour on individual bindings. (JS let/var) and also enrich @scope
captures in our queries to allow targeting them. Eg. @scope.function
vs @scope

One simple way of implementing the lexical scoping needed for Go or
Perl would be to record the source spans of bindings and use those to
determine references. (A definition always has to _lexically_ precede
a reference). This is a bit of a hack, it fails for example in OCaml
and its recursive-let bindings.

** Random implementation bits

The tree-sitter grammar for Go is poorly written for our use-case. We
might need to maintain a fork or get a change upstreamed. (namely
wrapping variable references in a named node so we can query them)

Removing non-locals from the results is probably easiest with a
post-processing pass. Ideally we'd be able to mark global bindings as
such in the tree-sitter queries, otherwise we might need some custom
code per language.
