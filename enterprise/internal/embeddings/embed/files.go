package embed

import (
	"fmt"
	"path/filepath"

	"strings"

	"github.com/grafana/regexp"

	"github.com/sourcegraph/sourcegraph/internal/conf"
	"github.com/sourcegraph/sourcegraph/internal/conf/conftypes"
)

const MIN_EMBEDDABLE_FILE_SIZE = 32
const MAX_LINE_LENGTH = 2048

var autogeneratedFileHeaders = []string{"autogenerated file", "lockfile", "generated by", "do not edit"}

var textFileExtensions = map[string]struct{}{
	"md":       {},
	"markdown": {},
	"rst":      {},
	"txt":      {},
}

var defaultExcludedFilePathRegexps = []*regexp.Regexp{
	regexp.MustCompile(`(?i)\.(sql|svg|json|yml|yaml)$`),
	regexp.MustCompile(`(?i)/?(__fixtures__|testdata|mocks|vendor|node_modules)/`),
}

var excludedFilePathRegexps = defaultExcludedFilePathRegexps

func init() {
	conf.ContributeValidator(func(c conftypes.SiteConfigQuerier) (problems conf.Problems) {
		embeddingsConf := c.SiteConfig().Embeddings
		if embeddingsConf == nil {
			return
		}

		for _, pattern := range embeddingsConf.ExcludedFilePathPatterns {
			if _, err := regexp.Compile(pattern); err != nil {
				problems = append(problems, conf.NewSiteProblem(fmt.Sprintf("Not a valid regexp: `%s`. See the valid syntax: https://golang.org/pkg/regexp/", pattern)))
			}
		}

		return
	})

	go func() {
		conf.Watch(func() {
			excludedFilePathRegexps = defaultExcludedFilePathRegexps

			config := conf.Get()
			if config == nil || config.Embeddings == nil {
				return
			}

			for _, pattern := range config.Embeddings.ExcludedFilePathPatterns {
				if re, err := regexp.Compile(pattern); err == nil {
					excludedFilePathRegexps = append(excludedFilePathRegexps, re)
				}
			}
		})
	}()
}

func isExcludedFilePath(filePath string) bool {
	for _, excludedFilePathRegexp := range excludedFilePathRegexps {
		if excludedFilePathRegexp.MatchString(filePath) {
			return true
		}
	}
	return false
}

func isEmbeddableFileContent(content string) bool {
	if len(strings.TrimSpace(content)) < MIN_EMBEDDABLE_FILE_SIZE {
		return false
	}

	lines := strings.Split(content, "\n")

	fileHeader := strings.ToLower(strings.Join(lines[0:min(5, len(lines))], "\n"))
	for _, header := range autogeneratedFileHeaders {
		if strings.Contains(fileHeader, header) {
			return false
		}
	}

	for _, line := range lines {
		if len(line) > MAX_LINE_LENGTH {
			return false
		}
	}

	return true
}

func isValidTextFile(fileName string) bool {
	ext := strings.TrimPrefix(filepath.Ext(fileName), ".")
	_, ok := textFileExtensions[strings.ToLower(ext)]
	if ok {
		return true
	}
	basename := strings.ToLower(filepath.Base(fileName))
	return strings.HasPrefix(basename, "license")
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
