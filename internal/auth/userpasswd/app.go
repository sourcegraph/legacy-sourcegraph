package userpasswd

import (
	"context"
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"sync"

	"github.com/sourcegraph/log"

	"github.com/sourcegraph/sourcegraph/cmd/frontend/globals"
	sgactor "github.com/sourcegraph/sourcegraph/internal/actor"
	"github.com/sourcegraph/sourcegraph/internal/conf/deploy"
	"github.com/sourcegraph/sourcegraph/internal/database"
	"github.com/sourcegraph/sourcegraph/internal/env"
	"github.com/sourcegraph/sourcegraph/internal/session"
	"github.com/sourcegraph/sourcegraph/internal/version"
	"github.com/sourcegraph/sourcegraph/lib/errors"
)

const appUsername = "admin"
const appTokenName = "App Autogenerated Token"
const appTokenScope = "user:all"
const appPayloadFileName = "app.json"

type AppTokenFilePayload struct {
	// Token prefixed with "sgp_"
	Token string `json:"token"`

	// The localhost API endpoint of App
	// Example: "http://localhost:3080"
	Endpoint string `json:"endpoint"`

	// App version string
	// Example: "2023.06.16"
	Version string `json:"version"`
}

// appSecret stores the in-memory secret used by Sourcegraph App to enable passworldless
// login from the console.
var appSecret secret

// secret is a base64 URL encoded string
type secret struct {
	mu    sync.Mutex
	value string
}

// Value returns the current secret value, or generates one if it has not yet
// been generated. An error can be returned if generation fails.
func (n *secret) Value() (string, error) {
	n.mu.Lock()
	defer n.mu.Unlock()

	if n.value != "" {
		return n.value, nil
	}

	value, err := randBase64(32)
	if err != nil {
		return "", errors.Wrap(err, "failed to generate secret from crypto/rand")
	}
	n.value = value

	return n.value, nil
}

// Verify returns true if clientSecret matches the current secret value.
func (n *secret) Verify(clientSecret string) bool {
	// We hold the lock the entire verify period to ensure we do not have
	// any replay attacks.
	n.mu.Lock()
	defer n.mu.Unlock()

	// The secret was never generated.
	if n.value == "" {
		return false
	}

	if subtle.ConstantTimeCompare([]byte(n.value), []byte(clientSecret)) != 1 {
		return false
	}
	return true // success
}

// AppSignInMiddleware will intercept any request containing a secret query
// parameter. If it is the correct secret it will sign in and redirect to
// search. Otherwise it will call the wrapped handler.
func AppSignInMiddleware(db database.DB, handler func(w http.ResponseWriter, r *http.Request) error) func(w http.ResponseWriter, r *http.Request) error {
	// This handler should only be used in App. Extra precaution to enforce
	// that here.
	if !deploy.IsApp() {
		return handler
	}

	return func(w http.ResponseWriter, r *http.Request) error {
		secret := r.URL.Query().Get("secret")
		if secret == "" {
			return handler(w, r)
		}

		if !appSecret.Verify(secret) && !env.InsecureDev {
			return errors.New("Authentication failed")
		}

		// Admin should always be UID=0, but just in case we query it.
		user, err := getByEmailOrUsername(r.Context(), db, appUsername)
		if err != nil {
			return errors.Wrap(err, "Failed to find admin account")
		}

		// Write the session cookie
		actor := sgactor.Actor{
			UID: user.ID,
		}
		if err := session.SetActor(w, r, &actor, 0, user.CreatedAt); err != nil {
			return errors.Wrap(err, "Could not create new user session")
		}

		err = createAppTokenFileIfNotExists(r.Context(), db, user.ID)
		if err != nil {
			fmt.Println("Error creating app token file", errors.Wrap(err, "Could not create app token file"))
		}

		// Success. Redirect to search or to "redirect" param if present.
		redirect := r.URL.Query().Get("redirect")
		u := r.URL
		if redirect != "" {
			redirectUrl, err := url.Parse(redirect)
			if err == nil {
				u.Path = redirectUrl.Path
				u.RawQuery = redirectUrl.RawQuery
			}
		} else {
			u.RawQuery = ""
			u.Path = "/search"
		}
		http.Redirect(w, r, u.String(), http.StatusTemporaryRedirect)
		return nil
	}
}

// Checks if the app token file exists in the config dir and contains a valid
// token. If not, it will generate a new token and create a new app token file.
func createAppTokenFileIfNotExists(ctx context.Context, db database.DB, uid int32) error {
	configDir, err := os.UserConfigDir()
	if err != nil {
		return errors.Wrap(err, "Could not get user config dir")
	}
	appPayloadFilePath := filepath.Join(configDir, appPayloadFileName)
	existingAccessTokenPresent := isExistingAppTokenPresent(ctx, db, appPayloadFilePath, uid)
	if existingAccessTokenPresent {
		return nil
	}

	return createAppTokenFile(ctx, db, appPayloadFilePath, uid)
}

// Attempts to read the app token file and checks if the token is valid,
// returning true if a valid token was found. Returns false if reading the file
// or validating the token fails.
func isExistingAppTokenPresent(ctx context.Context, db database.DB, appTokenFilePath string, uid int32) bool {
	fileContents, err := os.ReadFile(appTokenFilePath)
	if err != nil {
		return false
	}

	var payload AppTokenFilePayload
	err = json.Unmarshal(fileContents, &payload)
	if err != nil {
		return false
	}

	// Validate the token to confirm that it will be accepted by the API.
	_, err = db.AccessTokens().Lookup(ctx, payload.Token, appTokenScope)
	if err != nil {
		return false
	}

	return true
}

// Generate a new app token and write it to the app token file. Will overwrite
// if the file already exists.
func createAppTokenFile(ctx context.Context, db database.DB, appTokenFilePath string, uid int32) error {
	_, token, err := db.AccessTokens().Create(ctx, uid, []string{appTokenScope}, appTokenName, uid)
	if err != nil {
		return err
	}

	payload := AppTokenFilePayload{
		Token:    token,
		Endpoint: "http://localhost:3080", // TODO: we could use ExternalUrl() but it gives us https://sourcegraph.test:3443/ and we want the localhost port
		Version:  version.Version(),
	}

	appTokenFileBody, err := json.Marshal(payload)
	err = os.WriteFile(appTokenFilePath, appTokenFileBody, 0644)
	if err != nil {
		return err
	}

	return nil
}

// AppSiteInit is called in the case of Sourcegraph App to create the initial site admin account.
//
// Returns a sign-in URL which will automatically sign in the user. This URL
// can only be used once.
//
// Returns a nil error if the admin account already exists, or if it was created.
func AppSiteInit(ctx context.Context, logger log.Logger, db database.DB) (string, error) {
	password, err := generatePassword()
	if err != nil {
		return "", errors.Wrap(err, "failed to generate site admin password")
	}

	failIfNewUserIsNotInitialSiteAdmin := true
	err, _, _ = unsafeSignUp(ctx, logger, db, credentials{
		Email:    "app@sourcegraph.com",
		Username: appUsername,
		Password: password,
	}, failIfNewUserIsNotInitialSiteAdmin)
	if err != nil {
		return "", errors.Wrap(err, "failed to create site admin account")
	}

	// We have an account, return a sign in URL.
	return appSignInURL(), nil
}

func generatePassword() (string, error) {
	pw, err := randBase64(64)
	if err != nil {
		return "", err
	}
	if len(pw) > 72 {
		return pw[:72], nil
	}
	return pw, nil
}

func appSignInURL() string {
	externalURL := globals.ExternalURL().String()
	u, err := url.Parse(externalURL)
	if err != nil {
		return externalURL
	}
	secret, err := appSecret.Value()
	if err != nil {
		return externalURL
	}
	u.Path = "/sign-in"
	query := u.Query()
	query.Set("secret", secret)
	u.RawQuery = query.Encode()
	return u.String()
}

func randBase64(dataLen int) (string, error) {
	data := make([]byte, dataLen)
	_, err := rand.Read(data)
	if err != nil {
		return "", err
	}
	// Our secret ends up in URLs, so use URLEncoding.
	return base64.URLEncoding.EncodeToString(data), nil
}
