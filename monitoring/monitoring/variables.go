package monitoring

import (
	"fmt"
	"strings"

	"github.com/grafana-tools/sdk"
	"github.com/prometheus/prometheus/model/labels"

	"github.com/sourcegraph/sourcegraph/lib/errors"
	"github.com/sourcegraph/sourcegraph/monitoring/monitoring/internal/promql"
)

type ContainerVariableOptionType string

const (
	OptionTypeInterval = "interval"
)

type ContainerVariableOptions struct {
	Options []string
	// DefaultOption is the option that should be selected by default.
	DefaultOption string
	// Type of the options. You can usually leave this unset.
	Type ContainerVariableOptionType
}

type ContainerVariableOptionsLabel struct {
	// Query, the result of which is used to find Label.
	Query string
	// Label whose values to use as options.
	Label string
	// ExampleOption is an example of a valid option for this variable that may be
	// generated by Query, and must be provided if using Query.
	ExampleOption string
}

// ContainerVariable describes a template variable that can be applied container dashboard
// for filtering purposes.
type ContainerVariable struct {
	// Name is the name of the variable to substitute the value for, e.g. "alert_level"
	// to replace "$alert_level" in queries
	Name string
	// Label is a human-readable name for the variable, e.g. "Alert level"
	Label string

	// OptionsLabel defines label values to generate the possible options for this
	// variable (equivalent to 'label_values(.Query, .Label)'). Cannot be used in conjunction with Options.
	OptionsLabel ContainerVariableOptionsLabel
	// Options are the pre-defined possible options for this variable. Cannot be used in
	// conjunction with Query
	Options ContainerVariableOptions

	// WildcardAllValue indicates to Grafana that is should NOT use OptionsQuery or Options to
	// generate a concatonated 'All' value for the variable, and use a '.*' wildcard
	// instead. Setting this to true primarily useful if you use Query and expect it to be
	// a large enough result set to cause issues when viewing the dashboard.
	//
	// We allow Grafana to generate a value by default because simply using '.*' wildcard
	// can pull in unintended metrics if adequate filtering is not performed on the query,
	// for example if multiple services export the same metric. If set to true, make sure
	// the queries that use this variable perform adequate filtering to avoid pulling in
	// unintended metrics.
	WildcardAllValue bool

	// Multi indicates whether or not to allow multi-selection for this variable filter
	Multi bool
}

func (c *ContainerVariable) validate() error {
	if c.Name == "" {
		return errors.New("ContainerVariable.Name is required")
	}
	if c.Label == "" {
		return errors.New("ContainerVariable.Label is required")
	}
	if c.OptionsLabel.Query == "" && len(c.Options.Options) == 0 {
		return errors.New("one of ContainerVariable.OptionsQuery and ContainerVariable.Options must be set")
	}
	if c.OptionsLabel.Query != "" {
		if len(c.Options.Options) > 0 {
			return errors.New("ContainerVariable.OptionsQuery and ContainerVariable.Options cannot both be set")
		}
		if c.OptionsLabel.ExampleOption == "" {
			return errors.New("ContainerVariable.OptionsQuery.ExampleOption must be set")
		}
	}
	return nil
}

// toGrafanaTemplateVar generates the Grafana template variable configuration for this
// container variable.
func (c *ContainerVariable) toGrafanaTemplateVar(injectLabelMatchers []*labels.Matcher) (sdk.TemplateVar, error) {
	variable := sdk.TemplateVar{
		Name:  c.Name,
		Label: c.Label,
		Multi: c.Multi,

		Datasource: StringPtr("Prometheus"),
		IncludeAll: true,

		// Apply the AllValue to a template variable by default
		Current: sdk.Current{Text: &sdk.StringSliceString{Value: []string{"all"}, Valid: true}, Value: "$__all"},
	}

	if c.WildcardAllValue {
		variable.AllValue = ".*"
	} else {
		// Rely on Grafana to create a union of only the values
		// generated by the specified query.
		//
		// See https://grafana.com/docs/grafana/latest/variables/formatting-multi-value-variables/#multi-value-variables-with-a-prometheus-or-influxdb-data-source
		// for more information.
		variable.AllValue = ""
	}

	switch {
	case c.OptionsLabel.Query != "":
		variable.Type = "query"
		expr, err := promql.Inject(c.OptionsLabel.Query, injectLabelMatchers, nil)
		if err != nil {
			return variable, errors.Wrap(err, "OptionsLabel.Query")
		}
		variable.Query = fmt.Sprintf("label_values(%s, %s)", expr, c.OptionsLabel.Label)
		variable.Refresh = sdk.BoolInt{
			Flag:  true,
			Value: Int64Ptr(2), // Refresh on time range change
		}
		variable.Sort = 3

	case len(c.Options.Options) > 0:
		// Set the type
		variable.Type = "custom"
		if c.Options.Type != "" {
			variable.Type = string(c.Options.Type)
		}
		// Generate our options
		variable.Query = strings.Join(c.Options.Options, ",")

		// On interval options, don't allow the selection of 'all' intervals, since
		// this is a one-of-many selection
		var hasAllOption bool
		if c.Options.Type != OptionTypeInterval {
			// Add the AllValue as a default, only selected if a default is not configured
			hasAllOption = true
			selected := c.Options.DefaultOption == ""
			variable.Options = append(variable.Options, sdk.Option{Text: "all", Value: "$__all", Selected: selected})
		}
		// Generate options
		for i, option := range c.Options.Options {
			// Whether this option should be selected
			var selected bool
			if c.Options.DefaultOption != "" {
				// If an default option is provided, select that
				selected = option == c.Options.DefaultOption
			} else if !hasAllOption {
				// Otherwise if there is no 'all' option generated, select the first
				selected = i == 0
			}

			variable.Options = append(variable.Options, sdk.Option{Text: option, Value: option, Selected: selected})
			if selected {
				// Also configure current
				variable.Current = sdk.Current{
					Text: &sdk.StringSliceString{
						Value: []string{option},
						Valid: true,
					},
					Value: option,
				}
			}
		}
	}

	return variable, nil
}

func (c *ContainerVariable) getExampleValue() string {
	switch {
	case len(c.Options.Options) > 0:
		return c.Options.Options[0]
	case c.OptionsLabel.Query != "":
		return c.OptionsLabel.ExampleOption
	}
	return ""
}

type variableApplier struct{ vars []ContainerVariable }

var _ promql.VariableApplier = &variableApplier{}

func newVariableApplier(vars []ContainerVariable) promql.VariableApplier {
	return &variableApplier{
		vars: append(vars,
			// Make sure default Grafana variables are applied too
			ContainerVariable{
				Name: "__rate_interval",
				Options: ContainerVariableOptions{
					Options: []string{"123m"},
				},
			}),
	}
}

func (a *variableApplier) ApplyDefaults(expression string) string {
	for _, v := range a.vars {
		example := v.getExampleValue()
		expression = strings.ReplaceAll(expression, "$"+v.Name, example)
	}
	return expression
}

func (a *variableApplier) RevertDefaults(applied string) string {
	for _, v := range a.vars {
		applied = strings.ReplaceAll(applied, v.getExampleValue(), "$"+v.Name)
	}
	return applied
}
